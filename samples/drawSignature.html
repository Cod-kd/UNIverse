<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Drawing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        canvas {
            touch-action: none;
            cursor: cell;
            border: 1px solid #ccc;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        button {
            margin-top: 10px;
            padding: 10px 20px;
            font-size: 16px;
        }

        #outputDiv {
            margin-top: 20px;
            /* Space between buttons and output div */
            position: relative;
        }

        #qrCodeImage {
            margin-top: 20px;
            max-width: 128px;
            display: none;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <button id="resetCanvasBtn">Reset</button>
    <button id="saveCanvasBtn">Save</button>
    <div id="outputDiv"></div>
    <canvas id="qrCode"></canvas>
    <img id="qrCodeImage" style="display: none;" alt="QR Code" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

    <script>
        const canvas = document.getElementById("canvas");
        const resetCanvasBtn = document.getElementById("resetCanvasBtn");
        const saveCanvasBtn = document.getElementById("saveCanvasBtn");
        const outputDiv = document.getElementById("outputDiv");
        const qrCodeCanvas = document.getElementById("qrCode");
        const qrCodeImage = document.getElementById("qrCodeImage");

        let drawColor = "#FF5A1F";
        let drawWidth = 2;
        let isDrawing = false;

        // Canvas setup
        canvas.width = 300;
        canvas.height = 300;
        const context = canvas.getContext("2d");
        context.fillStyle = "#141414";
        context.fillRect(0, 0, canvas.width, canvas.height);

        // Event listeners for canvas drawing
        canvas.addEventListener("touchstart", startDrawing, { passive: false });
        canvas.addEventListener("touchmove", drawSignature, { passive: false });
        canvas.addEventListener("mousedown", startDrawing);
        canvas.addEventListener("mousemove", drawSignature);
        canvas.addEventListener("mouseup", stopDrawing);
        canvas.addEventListener("mouseout", stopDrawing);
        canvas.addEventListener("touchend", stopDrawing);
        canvas.addEventListener("touchcancel", stopDrawing);

        // Button event listeners
        resetCanvasBtn.addEventListener("click", clearCanvas);
        saveCanvasBtn.addEventListener("click", saveCanvas);

        // Helper function to get event position
        function getEventPosition(event) {
            const rect = canvas.getBoundingClientRect();
            if (event.touches && event.touches.length > 0) {
                return {
                    x: event.touches[0].clientX - rect.left,
                    y: event.touches[0].clientY - rect.top
                };
            } else {
                return {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
            }
        }

        // Canvas functions
        function startDrawing(event) {
            isDrawing = true;
            const pos = getEventPosition(event);
            context.beginPath();
            context.moveTo(pos.x, pos.y);
            event.preventDefault();
        }

        function drawSignature(event) {
            if (!isDrawing) return;
            const pos = getEventPosition(event);
            context.lineTo(pos.x, pos.y);
            context.strokeStyle = drawColor;
            context.lineWidth = drawWidth;
            context.lineCap = "round";
            context.lineJoin = "round";
            context.stroke();
            event.preventDefault();
        }

        function stopDrawing(event) {
            if (isDrawing) {
                isDrawing = false;
                event.preventDefault();
            }
        }

        function clearCanvas() {
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = "#141414";
            context.fillRect(0, 0, canvas.width, canvas.height);
        }

        async function hashImage(file) {
            const arrayBuffer = await file.arrayBuffer();
            const buffer = new Uint8Array(arrayBuffer);
            const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(byte => byte.toString(16).padStart(2, '0')).join('');
            return hashHex;
        }

        async function saveCanvas() {
            try {
                // Step 1: Capture the main canvas
                const canvasScreenshot = await html2canvas(canvas, { backgroundColor: null });

                // Step 2: Put the captured main canvas to the outputDiv
                outputDiv.innerHTML = ''; // Clear previous content
                outputDiv.appendChild(canvasScreenshot);

                // Step 3: Screenshot the outputDiv
                const outputDivScreenshot = await html2canvas(outputDiv);

                // Step 4: Convert the screenshot of outputDiv to hashHex
                outputDivScreenshot.toBlob(async (blob) => {
                    if (!blob) {
                        console.error("Blob is null, cannot proceed.");
                        throw new Error("Failed to create blob from outputDiv screenshot.");
                    }
                    const hashHex = await hashImage(blob);
                    console.log(`Image Hash: ${hashHex}`);
                    outputDiv.textContent += `Image Hash: ${hashHex}`; // Display the hash
                }, 'image/png');

            } catch (error) {
                console.error("Error in saveCanvas:", error);
                outputDiv.textContent = "An error occurred while processing the image.";
            }
        }

    </script>
</body>

</html>